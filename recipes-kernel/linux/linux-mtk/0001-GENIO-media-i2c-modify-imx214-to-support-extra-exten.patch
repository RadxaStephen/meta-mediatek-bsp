From d98b8c4c211858de9ba31ecaaf0b2d7cbd481626 Mon Sep 17 00:00:00 2001
From: RyanHsiao <ryan.hsiao@mediatek.com>
Date: Mon, 26 Sep 2022 14:38:24 +0800
Subject: [PATCH 1/3] GENIO: media: i2c: modify imx214 to support extra
 extension

modify imx214 upstream driver to support MediaTek extra extension
- SenTest:
  - V4L2_CID_MTK_SENSOR_PIXEL_RATE
- SenInf:
  - V4L2_CID_MTK_FRAME_DESC
  - V4L2_CID_MTK_CUST_SENSOR_PIXEL_RATE
  - V4L2_CID_MTK_CSI_PARAM
  - V4L2_CID_VSYNC_NOTIFY
  - V4L2_CID_MTK_SOF_TIMEOUT_VALUE
- PipeMgr:
  - V4L2_CID_MTK_SENSOR_STATIC_PARAM
  - V4L2_CID_MTK_MAX_FPS
  - V4L2_CID_MTK_SENSOR_TEST_PATTERN_DATA
  - V4L2_CID_MTK_ANTI_FLICKER
  - V4L2_CID_MTK_STAGGER_INFO
  - V4L2_CID_MTK_STAGGER_AE_CTRL

Change-Id: Id6fe3c9972c43830bb9bf8ada56379bc52d49423
Signed-off-by: RyanHsiao <ryan.hsiao@mediatek.com>
---
 drivers/media/i2c/imx214.c | 876 ++++++++++++++++++++++++++++++++++++-
 1 file changed, 871 insertions(+), 5 deletions(-)

diff --git a/drivers/media/i2c/imx214.c b/drivers/media/i2c/imx214.c
index 83c1737abeec..6d89748010c3 100644
--- a/drivers/media/i2c/imx214.c
+++ b/drivers/media/i2c/imx214.c
@@ -25,6 +25,235 @@
 #define IMX214_FPS 30
 #define IMX214_MBUS_CODE MEDIA_BUS_FMT_SRGGB10_1X10
 
+#define IMX214_DATA_LANES			4
+#define IMX214_SCLK					384000000LL
+#define IMX214_LINK_FREQ_450MHZ		450000000ULL
+#define IMX214_RGB_DEPTH			10
+#define IMX214_VTS_30FPS			0x0c7a
+#define IMX214_VTS_30FPS_MIN		0x0c7a
+#define IMX214_VTS_MAX				0xfff0
+#define IMX214_AGAIN_REG			0x0204
+#define IMX214_AGAIN_MIN			0
+#define IMX214_AGAIN_MAX			480
+#define IMX214_AGAIN_STEP			1
+#define IMX214_DGAIN_GR_REG			0x020e
+#define IMX214_DGAIN_R_REG			0x0210
+#define IMX214_DGAIN_B_REG			0x0212
+#define IMX214_DGAIN_GB_REG			0x0214
+#define IMX214_DGAIN_MIN			0x100
+#define IMX214_DGAIN_MAX			0xfff
+#define IMX214_DGAIN_STEP			1
+#define IMX214_FLIP_REG				0x0101
+#define IMX214_FLIP_H_MASK			0x1
+#define IMX214_FLIP_V_MASK			0x2
+
+#define sizeof_u32(__struct_name__) (sizeof(__struct_name__) / sizeof(u32))
+#define sizeof_u16(__struct_name__) (sizeof(__struct_name__) / sizeof(u16))
+
+#define USER_DESC_TO_IMGSENSOR_ENUM(DESC) \
+	((DESC) - VC_STAGGER_NE + \
+	IMGSENSOR_STAGGER_EXPOSURE_LE)
+#define IS_HDR_STAGGER(DESC) \
+	(((DESC) >= VC_STAGGER_NE) && \
+	((DESC) <= VC_STAGGER_SE))
+
+/**
+ * MTK CID
+ * The base for the mediatek sensor driver controls
+ * We reserve 48 controls for this driver.
+ */
+#define V4L2_CID_USER_MTK_SENSOR_BASE		(V4L2_CID_USER_BASE + 0x11a0)
+
+#define V4L2_CID_MTK_ANTI_FLICKER \
+	(V4L2_CID_USER_MTK_SENSOR_BASE + 2)
+#define V4L2_CID_MTK_MAX_FPS \
+	(V4L2_CID_USER_MTK_SENSOR_BASE + 14)
+#define V4L2_CID_MTK_STAGGER_AE_CTRL \
+	(V4L2_CID_USER_MTK_SENSOR_BASE + 15)
+#define V4L2_CID_MTK_STAGGER_INFO \
+	(V4L2_CID_USER_MTK_SENSOR_BASE + 17)
+#define V4L2_CID_MTK_SENSOR_PIXEL_RATE \
+	(V4L2_CID_USER_MTK_SENSOR_BASE + 22)
+#define V4L2_CID_MTK_FRAME_DESC \
+	(V4L2_CID_USER_MTK_SENSOR_BASE + 23)
+#define V4L2_CID_MTK_SENSOR_STATIC_PARAM \
+	(V4L2_CID_USER_MTK_SENSOR_BASE + 24)
+#define V4L2_CID_MTK_CUST_SENSOR_PIXEL_RATE \
+	(V4L2_CID_USER_MTK_SENSOR_BASE + 28)
+#define V4L2_CID_MTK_CSI_PARAM \
+	(V4L2_CID_USER_MTK_SENSOR_BASE + 29)
+#define V4L2_CID_MTK_SENSOR_TEST_PATTERN_DATA \
+	(V4L2_CID_USER_MTK_SENSOR_BASE + 30)
+#define V4L2_CID_MTK_SOF_TIMEOUT_VALUE \
+	(V4L2_CID_USER_MTK_SENSOR_BASE + 33)
+
+#define V4L2_CID_VSYNC_NOTIFY \
+	(V4L2_CID_CAMERA_CLASS_BASE + 37)
+
+struct mtk_mbus_frame_desc_entry_csi2 {
+	u8 channel;
+	u8 data_type;
+	u8 enable;
+	u16 hsize;
+	u16 vsize;
+	u16 user_data_desc;
+};
+
+struct mtk_mbus_frame_desc_entry {
+	union {
+		struct mtk_mbus_frame_desc_entry_csi2 csi2;
+	} bus;
+};
+#define MTK_FRAME_DESC_ENTRY_MAX 8
+
+
+enum mtk_mbus_frame_desc_type {
+	MTK_MBUS_FRAME_DESC_TYPE_PLATFORM,
+	MTK_MBUS_FRAME_DESC_TYPE_PARALLEL,
+	MTK_MBUS_FRAME_DESC_TYPE_CCP2,
+	MTK_MBUS_FRAME_DESC_TYPE_CSI2,
+};
+
+struct mtk_mbus_frame_desc {
+	enum mtk_mbus_frame_desc_type type;
+	struct mtk_mbus_frame_desc_entry entry[MTK_FRAME_DESC_ENTRY_MAX];
+	unsigned short num_entries;
+};
+
+struct mtk_csi_param {
+	__u8 dphy_trail;
+	__u8 dphy_data_settle;
+	__u8 dphy_clk_settle;
+	__u8 cphy_settle;
+};
+
+struct mtk_sensor_static_param {
+	__u32 scenario_id;
+	__u32 fps;
+	__u32 vblank;
+	__u32 hblank;
+	__u32 pixelrate;
+	__u32 cust_pixelrate;
+};
+
+enum IMGSENSOR_STAGGER_EXPOSURE {
+	IMGSENSOR_STAGGER_EXPOSURE_LE,
+	IMGSENSOR_STAGGER_EXPOSURE_ME,
+	IMGSENSOR_STAGGER_EXPOSURE_SE,
+	IMGSENSOR_STAGGER_EXPOSURE_SSE,
+	IMGSENSOR_STAGGER_EXPOSURE_SSSE,
+	IMGSENSOR_STAGGER_EXPOSURE_CNT,
+};
+
+struct mtk_hdr_exposure {
+	union {
+		struct {
+			__u32 le_exposure;
+			__u32 me_exposure;
+			__u32 se_exposure;
+			__u32 sse_exposure;
+			__u32 ssse_exposure;
+		};
+
+		__u32 arr[IMGSENSOR_STAGGER_EXPOSURE_CNT];
+	};
+
+};
+
+struct mtk_hdr_gain {
+	union {
+		struct {
+			__u32 le_gain;
+			__u32 me_gain;
+			__u32 se_gain;
+			__u32 sse_gain;
+			__u32 ssse_gain;
+		};
+
+		__u32 arr[IMGSENSOR_STAGGER_EXPOSURE_CNT];
+	};
+
+};
+
+struct mtk_hdr_ae {
+	struct mtk_hdr_exposure exposure;
+	struct mtk_hdr_gain gain;
+	__u32 actions;
+	__u32 subsample_tags;
+};
+
+struct mtk_stagger_info {
+	__u32 scenario_id;
+	__u32 count;
+	int order[IMGSENSOR_STAGGER_EXPOSURE_CNT];
+};
+
+enum VC_FEATURE {
+	VC_NONE = 0,
+	VC_MIN_NUM,
+	VC_RAW_DATA = VC_MIN_NUM,
+	VC_RAW_DATA_MAX,
+
+	VC_PDAF_MIN_NUM = VC_RAW_DATA_MAX,
+	VC_PDAF_STATS = VC_PDAF_MIN_NUM,
+	VC_PDAF_STATS_NE,
+	VC_PDAF_STATS_ME,
+	VC_PDAF_STATS_SE,
+	VC_PDAF_STATS_PIX_1,
+	VC_PDAF_STATS_PIX_2,
+	VC_PDAF_STATS_NE_PIX_1 = VC_PDAF_STATS_PIX_1,
+	VC_PDAF_STATS_NE_PIX_2 = VC_PDAF_STATS_PIX_2,
+	VC_PDAF_STATS_ME_PIX_1,
+	VC_PDAF_STATS_ME_PIX_2,
+	VC_PDAF_STATS_SE_PIX_1,
+	VC_PDAF_STATS_SE_PIX_2,
+	VC_PDAF_MAX_NUM,
+
+	VC_HDR_MIN_NUM = VC_PDAF_MAX_NUM,
+	VC_HDR_MVHDR = VC_HDR_MIN_NUM,
+	VC_HDR_MAX_NUM,
+
+	VC_3HDR_MIN_NUM = VC_HDR_MAX_NUM,
+	VC_3HDR_EMBEDDED = VC_3HDR_MIN_NUM,
+	VC_3HDR_FLICKER,
+	VC_3HDR_Y,
+	VC_3HDR_AE,
+	VC_3HDR_MAX_NUM,
+	VC_STAGGER_MIN_NUM = VC_3HDR_MAX_NUM,
+	VC_STAGGER_EMBEDDED = VC_STAGGER_MIN_NUM,
+	VC_STAGGER_NE,
+	VC_STAGGER_ME,
+	VC_STAGGER_SE,
+	VC_STAGGER_MAX_NUM,
+
+	VC_YUV_MIN_NUM = VC_STAGGER_MAX_NUM,
+	VC_YUV_Y = VC_YUV_MIN_NUM,
+	VC_YUV_UV,
+	VC_YUV_MAX_NUM,
+
+	VC_RAW_EXT_MIN_NUM = VC_YUV_MAX_NUM,
+	VC_RAW_W_DATA = VC_RAW_EXT_MIN_NUM,
+	VC_RAW_PROCESSED_DATA,
+	VC_RAW_EXT_MAX_NUM,
+
+	VC_GENERAL_DATA_MIN_NUM = VC_RAW_EXT_MAX_NUM,
+	VC_GENERAL_EMBEDDED = VC_GENERAL_DATA_MIN_NUM,
+	VC_GENERAL_DATA_MAX_NUM,
+
+	VC_MAX_NUM = VC_GENERAL_DATA_MAX_NUM,
+};
+
+struct mtk_test_pattern_data {
+	__u32 Channel_R;
+	__u32 Channel_Gr;
+	__u32 Channel_Gb;
+	__u32 Channel_B;
+};
+
+static const s64 link_freq_menu_items[] = {
+	IMX214_LINK_FREQ_450MHZ,
+};
+
 static const char * const imx214_supply_name[] = {
 	"vdda",
 	"vddd",
@@ -60,6 +289,12 @@ struct imx214 {
 	struct mutex mutex;
 
 	bool streaming;
+
+	struct i2c_client *client;
+	struct v4l2_ctrl *vblank;
+	struct v4l2_ctrl *hblank;
+	/* Current mode */
+	const struct imx214_mode *cur_mode;
 };
 
 struct reg_8 {
@@ -411,19 +646,146 @@ static const struct imx214_mode {
 	u32 width;
 	u32 height;
 	const struct reg_8 *reg_table;
+
+	u32 hts; /* Horizontal timining size */
+	u32 vts_def; /* Default vertical timining size */
+	u32 vts_min; /* Min vertical timining size */
+	u32 link_freq_index; /* Link frequency needed for this resolution */
+	u32 mipi_pixel_rate;
+	u32 max_framerate;
 } imx214_modes[] = {
 	{
 		.width = 4096,
 		.height = 2304,
 		.reg_table = mode_4096x2304,
+
+		.hts = 5008,
+		.vts_def = IMX214_VTS_30FPS,
+		.vts_min = IMX214_VTS_30FPS_MIN,
+		.link_freq_index = IMX214_DEFAULT_LINK_FREQ,
+		.mipi_pixel_rate = IMX214_DEFAULT_PIXEL_RATE,
+		.max_framerate = 300,
 	},
 	{
 		.width = 1920,
 		.height = 1080,
 		.reg_table = mode_1920x1080,
+
+		.hts = 5008,
+		.vts_def = IMX214_VTS_30FPS,
+		.vts_min = IMX214_VTS_30FPS_MIN,
+		.link_freq_index = IMX214_DEFAULT_LINK_FREQ,
+		.mipi_pixel_rate = IMX214_DEFAULT_PIXEL_RATE,
+		.max_framerate = 300,
+	},
+};
+
+static struct mtk_mbus_frame_desc_entry frame_desc_prev[] = {
+	{
+		.bus.csi2 = {
+			.channel = 0,
+			.data_type = 0x2b,
+			.hsize = 4096,
+			.vsize = 2304,
+		},
 	},
 };
 
+static u64 to_pixels_per_line(u32 hts)
+{
+	u64 ppl = hts * IMX214_DEFAULT_PIXEL_RATE;
+
+	do_div(ppl, IMX214_SCLK);
+
+	return ppl;
+}
+
+static int get_frame_desc(int scenario_id, struct mtk_mbus_frame_desc *fd)
+{
+	fd->type = MTK_MBUS_FRAME_DESC_TYPE_CSI2;
+	fd->num_entries = ARRAY_SIZE(frame_desc_prev);
+	memcpy(fd->entry, frame_desc_prev, sizeof(frame_desc_prev));
+
+	return 0;
+}
+
+static int get_static_params(struct imx214 *imx214, int scenario_id,
+	struct mtk_sensor_static_param *info)
+{
+	info->scenario_id = scenario_id;
+	info->fps = imx214->cur_mode->max_framerate / 10;
+	info->vblank = imx214->cur_mode->vts_def - imx214->cur_mode->height;
+	info->hblank = to_pixels_per_line(imx214->cur_mode->hts) - imx214->cur_mode->width;
+
+	if (info->hblank < 1)
+		info->hblank = 1;
+
+	info->pixelrate = imx214->cur_mode->mipi_pixel_rate;
+	info->cust_pixelrate = IMX214_DEFAULT_PIXEL_RATE;
+
+	return 0;
+}
+
+static int g_stagger_info(int scenario, struct mtk_stagger_info *info)
+{
+	int ret = 0;
+	struct mtk_mbus_frame_desc fd;
+	int hdr_cnt = 0;
+	unsigned int i = 0;
+
+	if (!info)
+		return 0;
+
+	ret = get_frame_desc(scenario, &fd);
+
+	if (!ret) {
+		for (i = 0; i < fd.num_entries; ++i) {
+			u16 udd =
+				fd.entry[i].bus.csi2.user_data_desc;
+
+			if (IS_HDR_STAGGER(udd)) {
+				hdr_cnt++;
+				info->order[i] = USER_DESC_TO_IMGSENSOR_ENUM(udd);
+			}
+		}
+	}
+
+	info->count = hdr_cnt;
+	return ret;
+}
+
+
+
+
+static int imx214_read_reg(struct imx214 *imx214, u16 reg, u16 len, void *val)
+{
+	return regmap_bulk_read(imx214->regmap, reg, val, len);
+
+}
+
+static int imx214_identify_module(struct imx214 *imx214)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&imx214->sd);
+	int ret;
+	u32 val;
+
+	ret = imx214_read_reg(imx214, 0x0016, 2, &val);
+	if (ret) {
+		dev_err(&client->dev, "read sensor_id failed: %d\n", ret);
+		return ret;
+	}
+
+	val = ((val & 0xff) << 8) | ((val & 0xff00) >> 8);
+	if (val != 0x0214) {
+		dev_err(&client->dev, "chip id mismatch: %x!=%x\n",
+			0x0214, val);
+		return -ENXIO;
+	}
+	dev_info(&client->dev, "sensor_id: 0x%04x\n", val);
+
+	return 0;
+}
+
 static inline struct imx214 *to_imx214(struct v4l2_subdev *sd)
 {
 	return container_of(sd, struct imx214, sd);
@@ -614,6 +976,8 @@ static int imx214_set_format(struct v4l2_subdev *sd,
 
 	format->format = *__format;
 
+	imx214->cur_mode = mode;
+
 	mutex_unlock(&imx214->mutex);
 
 	return 0;
@@ -649,12 +1013,56 @@ static int imx214_entity_init_cfg(struct v4l2_subdev *subdev,
 	return 0;
 }
 
+static int set_ext_ctrl(struct v4l2_ctrl *ctrl)
+{
+	int ret = 0;
+	struct imx214 *imx214 = container_of(ctrl->handler, struct imx214, ctrls);
+	struct i2c_client *client = v4l2_get_subdevdata(&imx214->sd);
+
+	switch (ctrl->id) {
+	/*
+	 * The MTK_CID_xxx below are not necessary to implement, but they should return 0
+	 * to avoid middle-ware execute error flow.
+	 */
+	case V4L2_CID_MTK_SENSOR_TEST_PATTERN_DATA:
+	case V4L2_CID_MTK_ANTI_FLICKER:
+	case V4L2_CID_MTK_MAX_FPS:
+	case V4L2_CID_MTK_STAGGER_AE_CTRL:
+	case V4L2_CID_MTK_STAGGER_INFO:
+	case V4L2_CID_MTK_SENSOR_STATIC_PARAM:
+	case V4L2_CID_VSYNC_NOTIFY:
+		dev_dbg(imx214->dev, "[imx214] set ext_ctrl CMD: 0x%x (%s : %d)\n",
+		  ctrl->id, __func__, __LINE__);
+		ret = 0;
+		break;
+
+	default:
+		dev_dbg(imx214->dev, "[imx214] un-handle CMD: 0x%x (%s : %d)\n",
+		  ctrl->id, __func__, __LINE__);
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
 static int imx214_set_ctrl(struct v4l2_ctrl *ctrl)
 {
 	struct imx214 *imx214 = container_of(ctrl->handler,
 					     struct imx214, ctrls);
 	u8 vals[2];
-	int ret;
+	int ret = 0;
+	s64 exposure_max;
+	struct i2c_client *client = v4l2_get_subdevdata(&imx214->sd);
+
+	if (ctrl->id == V4L2_CID_VBLANK) {
+		/* Update max exposure while meeting expected vblanking */
+		exposure_max = imx214->cur_mode->height + ctrl->val - 10;
+		__v4l2_ctrl_modify_range(imx214->exposure,
+					 imx214->exposure->minimum,
+					 exposure_max, imx214->exposure->step,
+					 exposure_max);
+	}
 
 	/*
 	 * Applying V4L2 control value only happens
@@ -673,8 +1081,81 @@ static int imx214_set_ctrl(struct v4l2_ctrl *ctrl)
 		ret = 0;
 		break;
 
+	case V4L2_CID_ANALOGUE_GAIN:
+		vals[1] = ctrl->val;
+		vals[0] = (ctrl->val >> 8) & 0x1;
+		ret = regmap_bulk_write(imx214->regmap, IMX214_AGAIN_REG, vals, 2);
+		if (ret < 0)
+			dev_err(imx214->dev, "Error %d\n", ret);
+		ret = 0;
+		break;
+
+	case V4L2_CID_DIGITAL_GAIN:
+		vals[1] = ctrl->val;
+		vals[0] = (ctrl->val >> 8) & 0xF;
+		ret = regmap_bulk_write(imx214->regmap, IMX214_DGAIN_GR_REG, vals, 2);
+		if (ret < 0) {
+			dev_err(imx214->dev, "Error %d\n", ret);
+			break;
+		}
+		ret = regmap_bulk_write(imx214->regmap, IMX214_DGAIN_R_REG, vals, 2);
+		if (ret < 0) {
+			dev_err(imx214->dev, "Error %d\n", ret);
+			break;
+		}
+		ret = regmap_bulk_write(imx214->regmap, IMX214_DGAIN_B_REG, vals, 2);
+		if (ret < 0) {
+			dev_err(imx214->dev, "Error %d\n", ret);
+			break;
+		}
+		ret = regmap_bulk_write(imx214->regmap, IMX214_DGAIN_GB_REG, vals, 2);
+		if (ret < 0) {
+			dev_err(imx214->dev, "Error %d\n", ret);
+			break;
+		}
+		break;
+
+	case V4L2_CID_VBLANK:
+		vals[1] = ctrl->val;
+		vals[0] = ctrl->val >> 8;
+		ret = regmap_bulk_write(imx214->regmap, 0x340, vals, 2);
+		if (ret < 0)
+			dev_err(imx214->dev, "Error %d\n", ret);
+		ret = 0;
+		break;
+
+	case V4L2_CID_HFLIP:
+		ret = imx214_read_reg(imx214, IMX214_FLIP_REG, 1, vals);
+		if (ret) {
+			dev_err(&client->dev, "read hflip register failed: %d\n", ret);
+			break;
+		}
+		vals[0] = (ctrl->val) ? (vals[0] | IMX214_FLIP_H_MASK)
+		  : (vals[0] & ~IMX214_FLIP_H_MASK);
+		ret = regmap_bulk_write(imx214->regmap, IMX214_FLIP_REG, vals, 1);
+		if (ret < 0)
+			dev_err(imx214->dev, "Error %d\n", ret);
+		break;
+
+	case V4L2_CID_VFLIP:
+		ret = imx214_read_reg(imx214, IMX214_FLIP_REG, 1, &vals);
+		if (ret) {
+			dev_err(&client->dev, "read vflip register failed: %d\n", ret);
+			break;
+		}
+		vals[0] = (ctrl->val) ? (vals[0] | IMX214_FLIP_V_MASK)
+		  : (vals[0] & ~IMX214_FLIP_V_MASK);
+		ret = regmap_bulk_write(imx214->regmap, IMX214_FLIP_REG, vals, 1);
+		if (ret < 0)
+			dev_err(imx214->dev, "Error %d\n", ret);
+		break;
+	case V4L2_CID_TEST_PATTERN:
+		ret = 0;
+		break;
+
 	default:
-		ret = -EINVAL;
+		ret = set_ext_ctrl(ctrl);
+		break;
 	}
 
 	pm_runtime_put(imx214->dev);
@@ -682,10 +1163,331 @@ static int imx214_set_ctrl(struct v4l2_ctrl *ctrl)
 	return ret;
 }
 
-static const struct v4l2_ctrl_ops imx214_ctrl_ops = {
+static int get_ext_ctrl(struct v4l2_ctrl *ctrl)
+{
+	int ret = 0;
+	struct imx214 *imx214 = container_of(ctrl->handler, struct imx214, ctrls);
+	struct i2c_client *client = v4l2_get_subdevdata(&imx214->sd);
+
+	dev_dbg(&client->dev, "---- %s, CMD:0x%x\n", __func__, ctrl->id);
+	switch (ctrl->id) {
+	case V4L2_CID_MTK_SOF_TIMEOUT_VALUE:
+		if (ctrl->val < (10000000 / imx214->cur_mode->max_framerate))
+			ctrl->val = 10000000 / imx214->cur_mode->max_framerate;
+
+		dev_dbg(&client->dev, "---- V4L2_CID_MTK_SOF_TIMEOUT_VALUE:%d\n", ctrl->val);
+		break;
+
+	case V4L2_CID_MTK_STAGGER_INFO:
+	{
+		struct mtk_stagger_info *info = ctrl->p_new.p;
+		u32 scenario_id = 0;
+
+		g_stagger_info(scenario_id, info);
+	}
+		break;
+
+	case V4L2_CID_VBLANK:
+		dev_dbg(&client->dev, "---- V4L2_CID_VBLANK:0x%x\n", V4L2_CID_VBLANK);
+		ctrl->val = imx214->cur_mode->vts_def - imx214->cur_mode->height;
+		break;
+
+	case V4L2_CID_HBLANK:
+		dev_dbg(&client->dev, "---- V4L2_CID_HBLANK:0x%x\n", V4L2_CID_HBLANK);
+		ctrl->val = to_pixels_per_line(imx214->cur_mode->hts) - imx214->cur_mode->width;
+		if (ctrl->val < 1)
+			ctrl->val = 1;
+		break;
+
+
+	case V4L2_CID_MTK_FRAME_DESC:
+	{
+		struct mtk_mbus_frame_desc *fd = ctrl->p_new.p;
+
+		dev_dbg(&client->dev, "---- V4L2_CID_MTK_FRAME_DESC:0x%x\n",
+		  V4L2_CID_MTK_FRAME_DESC);
+		get_frame_desc(0, fd);
+	}
+		break;
+
+	case V4L2_CID_MTK_CUST_SENSOR_PIXEL_RATE:
+		dev_dbg(&client->dev, "---- V4L2_CID_MTK_CUST_SENSOR_PIXEL_RATE:0x%x\n",
+		  V4L2_CID_MTK_CUST_SENSOR_PIXEL_RATE);
+		ctrl->val = imx214->cur_mode->mipi_pixel_rate;
+		break;
+
+	case V4L2_CID_MTK_SENSOR_PIXEL_RATE:
+		dev_dbg(&client->dev, "---- V4L2_CID_MTK_SENSOR_PIXEL_RATE:0x%x\n",
+		  V4L2_CID_MTK_SENSOR_PIXEL_RATE);
+		dev_dbg(&client->dev, "----mipi_pixel_rate: %d\n",
+		  imx214->cur_mode->mipi_pixel_rate);
+		ctrl->val = imx214->cur_mode->mipi_pixel_rate;
+		break;
+
+	case V4L2_CID_MTK_SENSOR_STATIC_PARAM:
+	{
+		struct mtk_sensor_static_param *info = ctrl->p_new.p;
+		u32 scenario_id = 0;
+
+		dev_dbg(&client->dev, "---- V4L2_CID_MTK_SENSOR_STATIC_PARAM:0x%x\n",
+		  V4L2_CID_MTK_SENSOR_STATIC_PARAM);
+		get_static_params(imx214, scenario_id, info);
+		dev_dbg(&client->dev,
+		  "[scenario %d]:fps: %d vb: %d hb: %d pixelrate: %d cust_pixel_rate: %d\n",
+		info->scenario_id, info->fps, info->vblank,
+		  info->hblank, info->pixelrate, info->cust_pixelrate);
+	}
+		break;
+
+	/*
+	 * The MTK_CID_xxx below are not necessary to implement, but they should return 0
+	 * to avoid middle-ware execute error flow.
+	 */
+	case V4L2_CID_MTK_CSI_PARAM:
+		dev_dbg(&client->dev, "---- V4L2_CID_MTK_CSI_PARAM\n");
+		break;
+
+	case V4L2_CID_MTK_MAX_FPS:
+		dev_dbg(&client->dev, "---- V4L2_CID_MTK_MAX_FPS\n");
+		break;
+
+	case V4L2_CID_MTK_ANTI_FLICKER:
+		dev_dbg(&client->dev, "---- V4L2_CID_MTK_ANTI_FLICKER\n");
+		break;
+
+	case V4L2_CID_VSYNC_NOTIFY:
+		dev_dbg(&client->dev, "---- V4L2_CID_VSYNC_NOTIFY\n");
+		break;
+
+	case V4L2_CID_MTK_STAGGER_AE_CTRL:
+		dev_dbg(&client->dev, "---- V4L2_CID_MTK_STAGGER_AE_CTRL\n");
+		break;
+
+	default:
+		dev_dbg(&client->dev, "[imx214] %s, un-support CMD: 0x%x\n", __func__, ctrl->id);
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+static int imx214_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
+{
+	int ret = 0;
+
+	switch (ctrl->id) {
+	default:
+		ret = get_ext_ctrl(ctrl);
+		break;
+	}
+
+	return ret;
+}
+
+static int try_ext_ctrl(struct v4l2_ctrl *ctrl)
+{
+	int ret = 0;
+	struct imx214 *imx214 = container_of(ctrl->handler, struct imx214, ctrls);
+	struct i2c_client *client = v4l2_get_subdevdata(&imx214->sd);
+
+	switch (ctrl->id) {
+	/*
+	 * The MTK_CID_xxx below are not necessary to implement, but they should return 0
+	 * to avoid middle-ware execute error flow.
+	 */
+	case V4L2_CID_TEST_PATTERN:
+	case V4L2_CID_MTK_SENSOR_TEST_PATTERN_DATA:
+	case V4L2_CID_MTK_ANTI_FLICKER:
+	case V4L2_CID_MTK_MAX_FPS:
+	case V4L2_CID_MTK_STAGGER_AE_CTRL:
+	case V4L2_CID_MTK_STAGGER_INFO:
+	case V4L2_CID_MTK_SENSOR_STATIC_PARAM:
+	case V4L2_CID_VSYNC_NOTIFY:
+		dev_dbg(imx214->dev, "[imx214] try ext_ctrl CMD: 0x%x (%s : %d)\n",
+		  ctrl->id, __func__, __LINE__);
+		ret = 0;
+		break;
+
+	default:
+		dev_dbg(imx214->dev, "[imx214] un-handle CMD: 0x%x (%s : %d)\n",
+		  ctrl->id, __func__, __LINE__);
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+static int imx214_try_ctrl(struct v4l2_ctrl *ctrl)
+{
+	int ret = 0;
+
+	switch (ctrl->id) {
+	default:
+		ret = try_ext_ctrl(ctrl);
+		break;
+	}
+
+	return ret;
+}
+
+
+const struct v4l2_ctrl_ops imx214_ctrl_ops = {
+	.g_volatile_ctrl = imx214_g_volatile_ctrl,
+	.try_ctrl = imx214_try_ctrl,
 	.s_ctrl = imx214_set_ctrl,
 };
 
+static const struct v4l2_ctrl_config cfg_mtkcam_pixel_rate = {
+	.ops = &imx214_ctrl_ops,
+	.id = V4L2_CID_MTK_SENSOR_PIXEL_RATE,
+	.name = "pixel rate",
+	.type = V4L2_CTRL_TYPE_INTEGER,
+	.flags = V4L2_CTRL_FLAG_READ_ONLY | V4L2_CTRL_FLAG_VOLATILE,
+	.max = 0x7fffffff,
+	.step = 1,
+};
+
+static const struct v4l2_ctrl_config cfg_mtkcam_cust_pixel_rate = {
+	.ops = &imx214_ctrl_ops,
+	.id = V4L2_CID_MTK_CUST_SENSOR_PIXEL_RATE,
+	.name = "customized pixel rate",
+	.type = V4L2_CTRL_TYPE_INTEGER,
+	.flags = V4L2_CTRL_FLAG_READ_ONLY | V4L2_CTRL_FLAG_VOLATILE,
+	.max = 0x7fffffff,
+	.step = 1,
+};
+
+static struct v4l2_ctrl_config cfg_fd_ctrl = {
+	.ops = &imx214_ctrl_ops,
+	.id = V4L2_CID_MTK_FRAME_DESC,
+	.name = "frame_des_ctrl",
+	.type = V4L2_CTRL_TYPE_U32,
+	.flags = V4L2_CTRL_FLAG_READ_ONLY | V4L2_CTRL_FLAG_VOLATILE,
+	.max = 0xffffffff,
+	.step = 1,
+	.dims = {sizeof_u32(struct mtk_mbus_frame_desc)},
+};
+
+static struct v4l2_ctrl_config cfg_csi_param_ctrl = {
+	.ops = &imx214_ctrl_ops,
+	.id = V4L2_CID_MTK_CSI_PARAM,
+	.name = "mtk_csi_param",
+	.type = V4L2_CTRL_TYPE_U32,
+	.flags = V4L2_CTRL_FLAG_READ_ONLY | V4L2_CTRL_FLAG_VOLATILE,
+	.max = 0xffffffff,
+	.step = 1,
+	.dims = {sizeof_u32(struct mtk_csi_param)},
+};
+
+static const struct v4l2_ctrl_config cfg_static_param = {
+	.ops = &imx214_ctrl_ops,
+	.id = V4L2_CID_MTK_SENSOR_STATIC_PARAM,
+	.name = "static param by scenario",
+	.type = V4L2_CTRL_TYPE_U32,
+	.flags = V4L2_CTRL_FLAG_VOLATILE,
+	.max = 0xffff,
+	.step = 1,
+	.dims = {sizeof_u32(struct mtk_sensor_static_param)},
+};
+
+static struct v4l2_ctrl_config cfg_ae_ctrl = {
+	.ops = &imx214_ctrl_ops,
+	.id = V4L2_CID_MTK_STAGGER_AE_CTRL,
+	.name = "ae_ctrl",
+	.type = V4L2_CTRL_TYPE_U32,
+	.flags = V4L2_CTRL_FLAG_EXECUTE_ON_WRITE,
+	.max = 0xffffffff,
+	.step = 1,
+	.dims = {sizeof_u32(struct mtk_hdr_ae)},
+};
+
+static const struct v4l2_ctrl_config cfg_mtkcam_sof_timeout_value = {
+	.ops = &imx214_ctrl_ops,
+	.id = V4L2_CID_MTK_SOF_TIMEOUT_VALUE,
+	.name = "sof timeout value",
+	.type = V4L2_CTRL_TYPE_INTEGER,
+	.flags = V4L2_CTRL_FLAG_READ_ONLY | V4L2_CTRL_FLAG_VOLATILE,
+	.max = 0x7fffffff,
+	.step = 1,
+};
+
+static const struct v4l2_ctrl_config cfg_stagger_info = {
+	.ops = &imx214_ctrl_ops,
+	.id = V4L2_CID_MTK_STAGGER_INFO,
+	.name = "stagger info",
+	.type = V4L2_CTRL_TYPE_U32,
+	.flags = V4L2_CTRL_FLAG_VOLATILE,
+	.max = 0xffff,
+	.step = 1,
+	.dims = {sizeof_u32(struct mtk_stagger_info)},
+};
+
+static const struct v4l2_ctrl_config cfg_max_fps = {
+	.ops = &imx214_ctrl_ops,
+	.id = V4L2_CID_MTK_MAX_FPS,
+	.name = "max_fps",
+	.type = V4L2_CTRL_TYPE_INTEGER,
+	.flags = V4L2_CTRL_FLAG_EXECUTE_ON_WRITE,
+	.max = 0xffff,
+	.step = 1,
+};
+
+static const struct v4l2_ctrl_config cfg_anti_flicker = {
+	.ops = &imx214_ctrl_ops,
+	.id = V4L2_CID_MTK_ANTI_FLICKER,
+	.name = "anti_flicker",
+	.type = V4L2_CTRL_TYPE_BOOLEAN,
+	.max = 1,
+	.step = 1,
+};
+
+
+static const struct v4l2_ctrl_config cfg_vsync_notify = {
+	.ops = &imx214_ctrl_ops,
+	.id = V4L2_CID_VSYNC_NOTIFY,
+	.name = "vsync_notify",
+	.type = V4L2_CTRL_TYPE_INTEGER,
+	.flags = V4L2_CTRL_FLAG_EXECUTE_ON_WRITE,
+	.max = 0xffff,
+	.step = 1,
+};
+
+static const struct v4l2_ctrl_config cfg_test_pattern_data = {
+	.ops = &imx214_ctrl_ops,
+	.id = V4L2_CID_MTK_SENSOR_TEST_PATTERN_DATA,
+	.name = "test_pattern_data",
+	.type = V4L2_CTRL_TYPE_U32,
+	.flags = V4L2_CTRL_FLAG_EXECUTE_ON_WRITE,
+	.max = 0xffffffff,
+	.step = 1,
+	.dims = {sizeof_u32(struct mtk_test_pattern_data)},
+};
+
+static int imx214_init_ext_controls(struct v4l2_ctrl_handler *ctrl_hdlr)
+{
+	v4l2_ctrl_new_custom(ctrl_hdlr, &cfg_fd_ctrl, NULL);
+
+	/* pixel rate for try control*/
+	v4l2_ctrl_new_custom(ctrl_hdlr, &cfg_mtkcam_pixel_rate, NULL);
+
+	/* pixel rate for special output timing*/
+	v4l2_ctrl_new_custom(ctrl_hdlr, &cfg_mtkcam_cust_pixel_rate, NULL);
+
+	v4l2_ctrl_new_custom(ctrl_hdlr, &cfg_csi_param_ctrl, NULL);
+	v4l2_ctrl_new_custom(ctrl_hdlr, &cfg_static_param, NULL);
+	v4l2_ctrl_new_custom(ctrl_hdlr, &cfg_max_fps, NULL);
+	v4l2_ctrl_new_custom(ctrl_hdlr, &cfg_test_pattern_data, NULL);
+	v4l2_ctrl_new_custom(ctrl_hdlr, &cfg_vsync_notify, NULL);
+	v4l2_ctrl_new_custom(ctrl_hdlr, &cfg_anti_flicker, NULL);
+	v4l2_ctrl_new_custom(ctrl_hdlr, &cfg_stagger_info, NULL);
+	v4l2_ctrl_new_custom(ctrl_hdlr, &cfg_mtkcam_sof_timeout_value, NULL);
+	v4l2_ctrl_new_custom(ctrl_hdlr, &cfg_ae_ctrl, NULL);
+	return 0;
+}
+
+
 #define MAX_CMD 4
 static int imx214_write_table(struct imx214 *imx214,
 			      const struct reg_8 table[])
@@ -765,7 +1567,7 @@ static int imx214_stop_streaming(struct imx214 *imx214)
 
 	ret = regmap_write(imx214->regmap, 0x100, 0);
 	if (ret < 0)
-		dev_err(imx214->dev, "could not sent stop table %d\n",	ret);
+		dev_err(imx214->dev, "could not sent stop table %d\n", ret);
 
 	return ret;
 }
@@ -801,6 +1603,15 @@ static int imx214_s_stream(struct v4l2_subdev *subdev, int enable)
 	return ret;
 }
 
+static int imx214_g_mbus_config(struct v4l2_subdev *sd, unsigned int pad,
+		struct v4l2_mbus_config *config)
+{
+	config->type = V4L2_MBUS_CSI2_DPHY;
+	config->flags = V4L2_MBUS_CSI2_4_LANE;
+
+	return 0;
+}
+
 static int imx214_g_frame_interval(struct v4l2_subdev *subdev,
 				   struct v4l2_subdev_frame_interval *fival)
 {
@@ -846,6 +1657,7 @@ static const struct v4l2_subdev_pad_ops imx214_subdev_pad_ops = {
 	.set_fmt = imx214_set_format,
 	.get_selection = imx214_get_selection,
 	.init_cfg = imx214_entity_init_cfg,
+	.get_mbus_config = imx214_g_mbus_config,
 };
 
 static const struct v4l2_subdev_ops imx214_subdev_ops = {
@@ -954,7 +1766,9 @@ static int imx214_probe(struct i2c_client *client)
 		.height = 1120,
 	};
 	int ret;
+	u64 h_blank;
 
+	dev_dbg(&client->dev, "[imx214] %s : %d\n", __func__, __LINE__);
 	ret = imx214_parse_fwnode(dev);
 	if (ret)
 		return ret;
@@ -967,7 +1781,7 @@ static int imx214_probe(struct i2c_client *client)
 
 	imx214->xclk = devm_clk_get(dev, NULL);
 	if (IS_ERR(imx214->xclk)) {
-		dev_err(dev, "could not get xclk");
+		dev_err(dev, "could not get xclk\n");
 		return PTR_ERR(imx214->xclk);
 	}
 
@@ -997,12 +1811,20 @@ static int imx214_probe(struct i2c_client *client)
 
 	v4l2_i2c_subdev_init(&imx214->sd, client, &imx214_subdev_ops);
 
+	imx214->cur_mode = &imx214_modes[0];
+
 	/*
 	 * Enable power initially, to avoid warnings
 	 * from clk_disable on power_off
 	 */
 	imx214_power_on(imx214->dev);
 
+	ret = imx214_identify_module(imx214);
+	if (ret) {
+		dev_err(&client->dev, "failed to find sensor: %d\n", ret);
+		return ret;
+	}
+
 	pm_runtime_set_active(imx214->dev);
 	pm_runtime_enable(imx214->dev);
 	pm_runtime_idle(imx214->dev);
@@ -1020,6 +1842,33 @@ static int imx214_probe(struct i2c_client *client)
 	if (imx214->link_freq)
 		imx214->link_freq->flags |= V4L2_CTRL_FLAG_READ_ONLY;
 
+	h_blank = to_pixels_per_line(imx214->cur_mode->hts) - imx214->cur_mode->width;
+	imx214->hblank = v4l2_ctrl_new_std(&imx214->ctrls, &imx214_ctrl_ops,
+					V4L2_CID_HBLANK, h_blank, h_blank, 1,
+					h_blank);
+	if (imx214->hblank)
+		imx214->hblank->flags |= V4L2_CTRL_FLAG_READ_ONLY;
+
+	imx214->vblank = v4l2_ctrl_new_std(&imx214->ctrls, &imx214_ctrl_ops,
+					V4L2_CID_VBLANK,
+					imx214->cur_mode->vts_min - imx214->cur_mode->height,
+					IMX214_VTS_MAX - imx214->cur_mode->height, 1,
+					imx214->cur_mode->vts_def - imx214->cur_mode->height);
+
+	v4l2_ctrl_new_std(&imx214->ctrls, &imx214_ctrl_ops,
+			  V4L2_CID_HFLIP, 0, 1, 1, 0);
+
+	v4l2_ctrl_new_std(&imx214->ctrls, &imx214_ctrl_ops,
+			  V4L2_CID_VFLIP, 0, 1, 1, 0);
+
+	v4l2_ctrl_new_std(&imx214->ctrls, &imx214_ctrl_ops, V4L2_CID_ANALOGUE_GAIN,
+			  IMX214_AGAIN_MIN, IMX214_AGAIN_MAX,
+			  IMX214_AGAIN_STEP, IMX214_AGAIN_MIN);
+
+	v4l2_ctrl_new_std(&imx214->ctrls, &imx214_ctrl_ops, V4L2_CID_DIGITAL_GAIN,
+			  IMX214_DGAIN_MIN, IMX214_DGAIN_MAX,
+			  IMX214_DGAIN_STEP, IMX214_DGAIN_MIN);
+
 	/*
 	 * WARNING!
 	 * Values obtained reverse engineering blobs and/or devices.
@@ -1054,6 +1903,23 @@ static int imx214_probe(struct i2c_client *client)
 	imx214->sd.dev = &client->dev;
 	imx214->sd.entity.function = MEDIA_ENT_F_CAM_SENSOR;
 
+	// Init ExtCMD
+	imx214_init_ext_controls(&imx214->ctrls);
+
+	dev_dbg(&client->dev, "imx214->sd.name: %s, dev->of_node->name: %s\n",
+		imx214->sd.name, dev->of_node->name);
+	if (V4L2_SUBDEV_NAME_SIZE - strlen(imx214->sd.name) - 2
+		< strlen(dev->of_node->name)) {
+		dev_err(&client->dev,
+			"the string length of (sd.name + of_node->name) is too long.\n");
+		return -EINVAL;
+	}
+	strncat(imx214->sd.name, " ", 1);
+	strncat(imx214->sd.name, dev->of_node->name,
+		V4L2_SUBDEV_NAME_SIZE - strlen(imx214->sd.name) - 2);
+	dev_dbg(&client->dev, "after: imx214->sd.name: %s\n", imx214->sd.name);
+
+
 	ret = media_entity_pads_init(&imx214->sd.entity, 1, &imx214->pad);
 	if (ret < 0) {
 		dev_err(dev, "could not register media entity\n");
-- 
2.18.0

